<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试题总结</title>
      <link href="/2022/05/24/mian-shi-ti-zong-jie/"/>
      <url>/2022/05/24/mian-shi-ti-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="1-解释IOC和DI">1. 解释IOC和DI</h3><ol><li><strong>IOC</strong>就是==控制反转==，指的是将创建对象的全力反转交给Spring，由Spring来为我们创建对象。而Spring底层采用的是==工厂+ XML+反射==，所以创建的对象是==低耦合==的。</li><li>DI指的是依赖注入，就是我们告诉Spring我们需要的对象有哪些依赖关系，Spring自动将这些依赖关系处理好。当我们使用对象时，Spring给我们具有==完整依赖的对象==。</li></ol><h3 id="2-Spring中Bean的线程安全问题">2. Spring中Bean的线程安全问题</h3><p>Spring中有作用域为单例和多例的两种Bean，</p><p>==多例==就是每次创建的都是一个新的对象，不存在共享，自然不会有线程安全问题；</p><p>==单例==就是Bean只有一个共享的实例存在，<br>如果是一个无状态的Bean，也就是不会对Bean的成员进行除查询以外的操作，它就是线程安全的；否则就存在线程安全问题，需要加锁；</p><h3 id="3-线程池原理（ThreadPoolExecutor）">3. 线程池原理（ThreadPoolExecutor）</h3><p>线程池是一种基于池化思想统一管理线程的工具，可以降低频繁创建和销毁线程造成的损耗.</p><p>ThreadPoolExecutor有七个参数：<br>1.常驻线程数（corePoolSize）<br>2.最大线程数（maximumPoolSize）<br>3.最大存活时间（keepAliveTime）<br>4.时间单位（unit）<br>5.阻塞队列（workQueue）<br>6.线程工厂（threadFactory）<br>7.拒绝策略（handler）</p><p>线程池初始化时，线程数为0<br>新任务提交时，如果线程数小于常驻线程数，则创建常驻线程；<br>如果线程数等于常驻线程数，则新任务进入阻塞队列；<br>如果阻塞队列满，且线程数小于最大线程数，则创建临时线程；<br>如果队列满，且线程数达到最大线程数，则根据拒绝策略，处理新任务。<br>当临时线程空闲时间达到最大存活时间，则销毁临时线程。<br>jdk大致提供了三种阻塞队，分别是有界队列、无界队列、SynchronousQueue。其中关于无界队列， 在阿里手册中明确指出: 无界队列由于本身很大， 无数的任务都可以提交到线程池， 会导致内存溢出的问题. 这也是为什么实际业务中应该避免使用原生线程池。</p><p><a href="#13">多线程的使用场景</a></p><h3 id="4-AOP和OOP的区别">4. AOP和OOP的区别?</h3><p>​<code>oop</code>是面向对象编程， 从纵向的角度处理问题; 对于共性内容， oop思想采用将共性向上抽取为父类， 再由子类继承父类的方式解决， 这种做法存在两个问题: 1.是java的单继承问题; 2.是需要手动调用.<br>​<code>aop</code>是面向切面编程， 横向看待问题; 将共性内容抽取成一个独立的通知模块， 通过将通知与切入点绑定形成切面， 然后织入具体目标方法中.<br>​aop基于代理模式， 可以在不惊动原始类的情况下，对其进行功能增强.</p><h3 id="5-Spring中的事务">5. Spring中的事务</h3><p>​Spring的事务是建立在数据库事务的基础之上的， 如果使用的数据库不支持事务， 则Spring的事务也会失效.<br>​Spring有编程式事务和声明式事务两种管理方式.<br>​<code>编程式事务</code>是在业务代码中使用Spring提供的管理事务的类， 这种事务管理会导致过高的代码侵入性， 且学习成本高;<br>​<code>声明式事务</code>的底层逻辑与编程式事务相同， 但是将管理事务的代码封装为切面， 使用AOP来达到管理事务的作用. 这种方式没有代码侵入性， 且学习成本低.</p><h3 id="6-Spring的事务传播行为">6. Spring的事务传播行为</h3><p>​Spring的事务传播行为是用来描述多个事务方法之间的事务关系， 也就是当事务由另一个事务调用时， 当前事务该如何传播.<br>​其中<code>requeied</code>表示如果没有事务，则创建事务，如果有事务，则加入事务;<br>​<code>requeied_new</code>表示无论有没有事务，都新建一个事务.<br>​例如留痕操作， 无论当前操作是否成功， 都需要将该操作记录下来， 则此时原始操作和记录日志应该分属两个事务.</p><hr><h3 id="7-Spring的事务失效有哪些情况">7. Spring的事务失效有哪些情况</h3><p>​1-当前类不归Spring管理<br>​2-异常被try…catch处理了<br>​3-未使用@Transaction配置事务操作<br>​4-Spring默认只处理运行时异常， 抛出编译时异常， Spring事务会失效<br>​5-Spring使用的数据库本身不支持事务<br>​6-Spring默认只处理public修饰的事务</p><hr><h3 id="8-HashMap相关">8. HashMap相关</h3><h4 id="8-1-HashMap的结构">8.1- HashMap的结构</h4><p>​hashmap结构在jdk1.7和1.8是不同的，<br>​1.7底层使用的是==数组+链表==;<br>​1.8底层使用的是==数组+链表+红黑树==.  1.8中当链表长度大于8， 并且数组容量超过64时链表会转换为红黑树; 当红黑树节点数小于6时， 红黑树会转为链表.</p><hr><h4 id="8-2-Hash算法-寻址算法">8.2- Hash算法(寻址算法)</h4><p>​hashmap计算索引时， 元素可能落在相同的位置上， 从而产生哈希冲突. java的hashmap底层采用的是链地址法来解决哈希冲突， 但是链表的查询性能较低， 所以需要使用寻址算法， 使得不同元素尽可能落在不同位置.<br>​<code>寻址算法</code>就是hashcode的高低16位异或运算， 再与上2的n次幂减一得到数组索引<br>​((key.hashCode= h)  ^ (h&gt;&gt;&gt;16) )   &amp;   数组长度(2的N次幂) -1    =  数组索引<br>​其中使用hashcode的<code>高低16位</code>运算是为了让32位二进制尽可能的参与运算， 采用<code>异或运算</code>是因为得到0，1平均概念最高的运算;<br>​采用<code>与运算</code>是因为与运算是速度最快的二进制运算; <code>2的N次幂 -1</code>是为了得到一个奇数， 因为偶数参与&amp;运算得到的一定是偶数;<br>​采用&amp;和( 数组长度-1 )可以保证算出来的索引是在 (0 ~ 数组长度-1 )的这个范围中， 避免越界.</p><hr><h4 id="8-3-Hashmap的扩容">8.3- Hashmap的扩容</h4><p>​当Map集合中元素个数达到阈值(0.75*容量)时， 就会进行扩容.<br>​Java1.7中Map扩容时会生成一个新的集合， 然后将旧集合中的元素<code>重新进行一次寻址</code>算法， 得到元素在新数组中的索引.<br>​java1.8中生成新集合后， 将原始的哈希值和旧集合容量进行与运算， 如果结果为0，则元素索引不变; 否则新的索引为(<code>原索引+旧集合容量</code>)</p><hr><h4 id="8-4-HashMap存在哪些线程安全问题">8.4- HashMap存在哪些线程安全问题</h4><p>​1.7使用尾插发可能是因为后来的元素大概率会先被使用， 采用头插法可以很快取出. 但是头插法存在线程安全问题， 如果在插入时进行扩容， 可能出现死循环问题.</p><p>​hashmap本身也存在线程安全问题， 例如丢失数据.</p><hr><h4 id="8-5-ConcurrentHashMap">8.5- ConcurrentHashMap</h4><p>…</p><h4 id="8-6-为什么ConcurrentHashMap的键和值都不能为空">8.6-为什么ConcurrentHashMap的键和值都不能为空?</h4><h3 id="9-并发编程相关">9. 并发编程相关</h3><h5 id="1-什么是并发编程">1-什么是并发编程</h5><p>​并发编程就是多个线程之间在通信，传递数据，相互等待等，共同配合起来完成一件事情.</p><h5 id="2-cpu缓存模型">2-cpu缓存模型</h5><p>​现代计算机为了解决cpu频繁读写内存的问题， 给cpu增加了缓存机制. 这样一来cpu就可以将数据从主内存中加载到缓存中， 然后在自己对应的缓存中进行数据的操作，而不需要频繁的跟主内存通信.<br>​但是这样就可能导致数据不一致的问题， 也就是cpu在一个线程中对数据进行修改后未能写入到主内存中，另一个线程就无法感应到修改后的数据. 所以使用了MESI缓存一致性协议来解决这个问题.<br>​MESI协议会强制修改的数据写会主内存;<br>​使用到了嗅探机制：当cpu写完之后，向其他cpu发送一个指令，让其他cpu中的缓存失效，从而使其他cpu重新从内存中加载数据.</p><h5 id="3-Java内存模型">3-Java内存模型</h5><p>​Java内存模型是基于cpu缓存模型来建立的， 屏蔽掉底层不同的系统的区别.Java内存模型将存放数据的地方分成了工作内存和主内存. 成员变量存放在主内存中， 局部变量会加载到工作内存中.</p><h5 id="4-并发编程三大问题">4-并发编程三大问题</h5><p>​并发编程存在三大问题.<br>​首先是<code>可见性问题</code>: 工作内存中的数据未及时写回主内存; 或者线程未能感知到主内存数据发生变化， 没有读取新数据. 也就是一个线程对数据的操作对其他线程是不可见的;<br>​然后是<code>原子性问题</code>: 也就是一个线程对数据的操作为结束， 而另外一个线程也对该数据进行了操作;<br>​最后是<code>重排序问题</code>:  Java 编译器会不改变结果的情况下，对指令进行重新排序， 来提高执行效率.</p><h5 id="5-volatile关键字">5-volatile关键字</h5><p>​使用volatile关键字，只要assign成功， 就会将数据强制进行store+write，相当于MESI协议中<code>强制写回主内存</code>;  同时让其他cpu工作内存中的数据失效，然后其他cpu就只能重新读取数据， 保证其他cpu感知最新数据.<br>​volatile关键字还可以<code>禁止指令重排</code>. 但无法解决原子性问题.</p><h3 id="10-自动装配">10.自动装配</h3><p>​自动装配就是SpringBoot在程序初始化时， 根据classpath、property属性等各种动态条件，按需初始化相应的bean，并注册到IOC容器中。<br>​SpringBoot启动类上的@SpringBootApplication注解由@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解组成，三个注解共同完成自动装配.<br>​@SpringBootConfiguration 注解标记启动类为配置类;<br>​@ComponentScan 注解实现启动时扫描启动类所在的包以及子包下的类;<br>​@EnableAutoConfiguration通过 @Import 注解导入 AutoConfigurationImportSelector类，然后通过AutoConfigurationImportSelector 类的 selectImports 方法去读取需要被自动装配的组件依赖下的spring.factories文件中的全类名，并按照一定的规则过滤掉不符合要求的全类名，将剩余读取到的各个组件的全类名集合返回给IOC容器并将这些组件注册为bean<br>​以redis为例， @Conditional 注解判断是否导入对应的starter; @ConditionalmissBean 注解判断容器中是否有该类的Bean，如果没有该bean，就会创建一个对象，将该对象放入到容器中去.</p><pre><code>1、当启动springboot应用程序的时候，会先创建SpringApplication的对象，在对象的构造方法中会进行某些参数的初始化工作，最主要的是判断当前应用程序的类型以及初始化器和监听器，在这个过程中会加载整个应用程序中的spring.factories文件，将文件的内容放到缓存对象中，方便后续获取。2、SpringApplication对象创建完成之后，开始执行run方法，来完成整个启动，启动过程中最主要的有两个方法，第一个叫做prepareContext，.第二个叫做refreshContext，在这两个关键步骤中完成了自动装配的核心功能，前面的处理逻辑包含了上下文对象的创建，banner的打印，异常报告期的准备等各个准备工作，方便后续来进行调用。3、在prepareContext方法中主要完成的是对上下文对象的初始化操作，包括了属性值的设置，比如环境对象，在整个过程中有一个非常重要的方法，叫做load，load主要完成一件事，将当前启动类做为一个beanDefinition注册到registry中，方便后续在进行BeanFactoryPostProcessor调用执行的时候，找到对应的主类，来完成@SpringBootApplicaiton， @EnableAutoConfiguration等注解的解析工作4、在refreshContext方法中会进行整个容器刷新过程，会调用中spring中的refresh方法，refresh中有13个非常关键的方法，来完成整个spring应用程序的启动，在自动装配过程中，会调用invokeBeanFactoryPostProcessor方法，在此方法中主要是对ConfigurationClassPostProcessor类的处理，这是BFPP的子类也是BDRPP的子类，在调用的时候会先调用BDRPP中的postProcessBeanDefinitionRegistry方法，然后调用postProcessBeanFactory方法，在执行postProcesseanDefinitionRegistry的时候解析处理各种注解，包含@PropertySource， @ComponentScan， @ComponentScans， @Bean， @Import等注解，最主要的是@Import注解的解析5、在解析@Import注解的时候，会有一个getImports的方法，从主类开始递归解析注解，把所有包含@Import的注解都解析到，然后在processImport方法中对Import的类进行分类，此处主要识别的时候AutoConfigurationImportSelect归属于ImportSelect的子类，在后续过程中会调用deferredImportSelectorHandler中的process方法，来完整EnableAutoConfiguration的加载。</code></pre><h3 id="11-Atomic原子类">11. Atomic原子类</h3><p>​Atomic类采用的是一个类似于乐观锁的CAS机制来解决线程安全问题.<br>​<code>CAS机制</code>就是当我们需要对变量进行修改时， 会先从主内存中读取值， 如果该值与个工作内存中的值相等， 就会将修改值写入主内存; 如果不相等， 就会进行<code>循环</code>， 再次获取主内存中的值进行compareAndSwap.这个过程具有原子性， 且该操作获得cpu底层支持， 性能比Synchronized锁的性能高很多.<br>​Atomic底层是基于<code>unsafe类</code>来操作的， 该类是JDK内部使用的， 不对外开放， 它封装了一些不安全的操作. unsafe会去获得atomic底层 计数值value，这个value被volatile关键字修饰， 保证了可见性; 然后有一个静态代码块：会算出当前这个value的 系统偏移量，通过一种类似C 语言指针的操作去拿到 当前这个 value值.<br>​但是Atomic存在两个问题:</p><h4 id="Atomic原子性类CAS存在的两大缺点">Atomic原子性类CAS存在的两大缺点</h4><p>​一个是<code>ABA问题</code>(AtomicStampedReference) ， 也就是线程1获取变量x的值a， 对a进行处理; 此时线程2页获取了变量x的值a， 并将值改为b， 然后又改回a; 当线程1处理完a后， 发现主内存中的x依然为a， 就执行写入. 但是这个过程中x的值发生过变化. 可以使用加入版本号的方式来解决这个问题.</p><p>​还有一个问题是， 在高并发情况下，会有大量的线程执行不成功，由于<code>自旋</code>导致cpu的开销很大.</p><h4 id="利用LongAdder分布CAS机制优化多线程自旋问题">利用LongAdder分布CAS机制优化多线程自旋问题</h4><p>​jdk1.8之后提供了一个LongAdder类来解决高并发情况下的自旋问题.<br>​LongAdder的底层有一个base值， 在低并发时， 线程都是对base进行操作; 在高并发时， 会有一个cell数组， 多个线程去操作对应的cell. 这样就可以大幅度的降低多线程并发更新同一个数值时出现的无限循环的问题.<br>​它的内部有这样一个机制机制，就是如果某个cell的value更新失败，那么就会自动去找另外一个cell分段内的value值进行操作.最后，如果要从LongAdder中获取当前累加的总值，就会把base值和所有cell分段数值加起来返回.<br><img src="./面试题总结.assets/image-20220512015238084.png" alt="image-20220512015238084" style="zoom: 50%;" /></p><h4 id="手写一个自旋锁">手写一个自旋锁</h4><pre class="line-numbers language-language-java"><code class="language-language-java">interface SpinLock&#123;    void lock();    void unlock();&#125;class SpinLockCas implements SpinLock&#123;    AtomicInteger atomic = new AtomicInteger(0);    @Override    public void lock() &#123;        while(!atomic.compareAndSet(0,1))&#123;        &#125;    &#125;    @Override    public void unlock() &#123;        atomic.compareAndSet(1,0);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-ReentrantLock相关">12. ReentrantLock相关</h3><h4 id="什么是可重入锁">什么是可重入锁?</h4><p>​可重入锁又叫递归锁， 也就是当一个线程获取锁对象后， 这个线程可以再次获取这个锁， 可在一定程度上防止死锁.<br>​其原理是可重入锁会记录获取锁的线程， 还有一个计数器; 无锁状态时计数器为0; 线程获取锁后， 计数器变为1; 当该线程再次获取锁时， 计数器+1;</p><blockquote><p>加了几次锁就有释放几次锁</p></blockquote><pre class="line-numbers language-language-java"><code class="language-language-java">public class Demo &#123;    public static void main(String[] args) &#123;        ReentrantLock lock = new ReentrantLock();        lock.lock();            System.out.println(Thread.currentThread().getId()+ "--我获得了锁");            lock.lock();                System.out.println(Thread.currentThread().getId() + "--我又获得了锁");            lock.unlock();        lock.unlock();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ReentrantLock原理-重点-非公平锁为例">ReentrantLock原理(重点, 非公平锁为例)</h4><p>​多个进程竞争同一个资源时， 先获取资源的进程会进行加锁， 将state设置为1. 其他竞争失败的进程会依次放入到一个队列中(基于双向链表)， 并睡眠(释放持有的其他资源). 当获得资源的进程处理结束后会释放锁， 将state设置为0，同时从队列中唤醒一个进程. 默认情况下， ReentrantLock是<a href="#reentrantlock">非公平锁</a>， 唤醒后的进程需要和其他进程重新竞争锁.</p><img src="./面试题总结.assets/image-20220512020635455.png" alt="image-20220512020635455" style="zoom: 67%;" /><h4 id="ReentrantLock和AQS">ReentrantLock和AQS</h4><p>​ReentrantLock是一个AQS的包装类</p><h4 id="说一下公平锁和非公平锁-a-id-reentrantlock-a">说一下公平锁和非公平锁<a id="reentrantlock"> </a></h4><p>​<code>公平锁</code>：多个线程按照申请锁的顺序去获得锁。不会导致饥饿，但是吞吐量会下降。</p><p>​<code>非公平锁</code>：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。可以减少cpu唤醒线程的开销，但是可能导致饥饿</p><p><strong>原理:</strong></p><p>…</p><h3 id="13-多线程的使用场景-a-id-13-a">13. 多线程的使用场景<a id="13"> </a></h3><p>​实际业务中，多线程主要有两个使用场景:<br>​一个是<code>快速响应用户请求</code>，比如我们查询一个商品信息时，需要从多个表中查询相关信息并将这些信息聚合起来。使用多线程分别去执行这些查询操作，可以缩短总体响应时间；这种场景需要考虑并发率，可以使用SynchronousQueue作为阻塞队列。</p><img src="https://p0.meituan.net/travelcube/e9a363c8577f211577e4962e9110cb0226733.png" alt="图12 并行执行任务提升任务响应速度" style="zoom: 80%;" /><p>​另一个是<code>快速处理批量任务</code>，比如需要执行大量的查询任务，为了提高效率，我们可以将大任务拆分为小任务交给线程去执行.这种场景应该考虑吞吐量，所以需要设置有界队列去缓存任务.</p><img src="https://p1.meituan.net/travelcube/1a1746f33bfdcb03da074d8539ebb2f367563.png" alt="图13 并行执行任务提升批量任务执行速度" style="zoom: 50%;" /><h4 id="线程池参数配置">线程池参数配置</h4><p>​线程数并不是设置的越大越好，过多的线程会导致线程上下文切换频繁的问题，会降低任务的处理速度.参考设置:coreSize=2<em>N~cpu~，maxSize=25</em>N~cpu~.</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
